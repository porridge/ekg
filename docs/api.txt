// szybki kurs libgadu
// (c) copyright 2001-2003 by wojtek kaniewski <wojtekka@irc.pl>
//			      robert j. wozny <speedy@ziew.org>

// tekst poprawiany ostatnio 2003-10-03

ka¿da sesja jest opisywana przez ,,struct gg_session''. biblioteka mo¿e
w ramach jednego procesu/w±tku obs³ugiwaæ tyle sesji, na ile pozwol±
zasoby. na pocz±tku deklarujemy:

	struct gg_session *blah;

nastêpnie bêdziemy siê ³±czyæ. przyk³ad bêdzie dotyczy³ socketów
nieblokuj±cych, bo w wiêkszo¶ci aplikacji ciê¿ko sobie pozwoliæ na
zawieszanie programu na czas ³±czenia.

	struct gg_login_params p;

	memset(&p, 0, sizeof(p));
	p.uin = 123456;
	p.password = "has³o";
	p.async = 1;
	p.status = GG_STATUS_INVISIBLE;

	if (!(blah = gg_login(&p)))
		my_error();

je¶li uda siê rozpocz±æ proces ³±czenia, dostajemy wska¼nik do struktury,
inaczej NULL. wywo³anie gg_login() powoduje uruchomienie drugiego procesu
lub w±tku w tle, który wywo³a gethostbyname() i potokiem zwróci wynik.
pó¼niej po³±czy siê z serwerem, wy¶le, odbierze, po³±czy siê ze wskazanym
adresem IP, zaloguje siê itd. jako ¿e wszystko dziejê siê w tle, klient
musi sprawdzaæ ca³y czas podane deskryptory. pole ,,blah->fd'' zawiera
deskryptor, a ,,blah->check'' jest bitmap± i zawiera GG_CHECK_READ i/lub
GG_CHECK_WRITE je¶li mamy sprawdziæ czy przysz³y nowe dane i/lub mo¿emy
wysy³aæ. je¶li co¶ siê wydarzy, wywo³ujemy ,,gg_watch_fd()'', a libgadu
sobie ju¿ sprawdzi, co takiego siê zdarzy³o:

	while (1) {
		fd_set rd, wr, ex;

		FD_ZERO(&rd);
		FD_ZERO(&wr);
		FD_ZERO(&ex);

		if ((blah->check & GG_CHECK_READ))
			FD_SET(blah->fd, &rd);
		if ((blah->check & GG_CHECK_WRITE))
			FD_SET(blah->fd, &wr);
		FD_SET(blah->fd, &ex);

		if (select(blah->fd + 1, &rd, &wr, &ex, NULL) == -1)
			my_error();

		if (FD_ISSET(blah->fd, &ex))
			my_error();

		if (FD_ISSET(blah->fd, &rd) || FD_ISSET(blah->fd, &wr))
			my_handle_event();
	}

dla uproszczenia, nie ma tutaj obs³ugi timeoutów i tym podobnych dodatków.
poza tym, je¶li program sprawdza te¿ inne deskryptory (np. stdin dla
klientów konsolowych), dobrze by³oby sprawdziæ, czy dana sesja co¶ robi i
nie sprawdzaæ ,,blah->fd'' je¶li ,,blah->state == GG_STATE_IDLE''. od czasu
do czasu mo¿na daæ serwerowi znaæ, ¿e co¶ siê dzieje, za pomoc±...

	gg_ping(blah);

ale to ju¿ wymaga implementacji timerów i liczenia czasu od ostatniego
pinga. ,,blah->last_event'' mówi, kiedy dostali¶my cokolwiek ostatnio od
serwera. wszystkie pola struktury s± opisane w pliku libgadu.h.

wracaj±c do obs³ugi deskryptorów -- je¶li klient zauwa¿y, ¿e co¶ siê
zmieni³o na podanym sockecie, powinien wywo³aæ ,,gg_watch_fd()'',
która wszystkim siê zajmie. zwraca ona wska¼nik do zaalokowanej
struktury opisuj±cej zdarzenie. po obejrzeniu nale¿y zwolniæ j± za
pomoc± ,,gg_event_free()''. w powy¿szym przyk³adzie jest wywo³ywana
funkcja ,,my_handle_event()'', która mo¿e wygl±daæ tak:

	struct gg_event *e;
	
	if (!(e = gg_watch_fd(blah)))
		my_error();

	switch (e->type) {
		case GG_EVENT_NONE:
		case GG_EVENT_PONG:
			/* olewamy */
			break;

		case GG_EVENT_CONN_SUCCESS:
			printf("po³±czono!\n");
			/* tutaj wysy³amy userlistê za pomoc± gg_notify() */
			break;

		case GG_EVENT_CONN_FAILED:
			printf("nie uda³o siê\n");
			/* powód w e->event.failure, sta³e GG_FAILURE_... */
			break;

		case GG_EVENT_MSG:
			printf("masz wiadomo¶æ!\n");
			printf("od: %d\n", e->event.msg.sender);
			printf("tre¶æ: %s\n", e->event.msg.message);
			/* e->event.msg.class mówi czy rozmowa czy wiad. */
			/* je¶li e->event.msg.sender równy 0, to mamy */
			/* wiadomo¶æ systemow± o numerze w msg.class */
			break;

		case GG_EVENT_NOTIFY:
			printf("oto ludzie, którzy siê pojawili: ");
			/* tutaj sprawdzanie tablicy e->event.notify */
			break;

		case GG_EVENT_NOTIFY60:
			printf("oto ludzie, którzy siê pojawili: ");
			/* tutaj sprawdzanie tablicy e->event.notify60 */
			break;

		case GG_EVENT_STATUS:
			printf("kto¶ %d zmieni³ stan\n", e->event.status.uin);
			/* nowy stan w e->event.status.status */
			break;

		case GG_EVENT_STATUS60:
			printf("kto¶ %d zmieni³ stan\n", e->event.status60.uin);
			/* nowy stan w e->event.status60.status */
			break;

		case GG_EVENT_ACK:
			printf("wiadomo¶æ dotar³a do %d.\n",
				e->event.ack.recipient);
			/* e->event.ack.status mówi czy dotar³a do klienta */
			/* czy le¿y na serwerze, sta³e GG_ACK_... */
			/* e->event.ack.seq to numerek wiadomo¶ci */
			break;

		case GG_EVENT_PUBDIR50_REPLY:
			printf("znalaz³o kogo¶\n");
			/* opisane ni¿ej */
			break;

		case GG_EVENT_USERLIST:
			printf("wys³ano lub odebrano listê z serwera\n");
			/* opisane ni¿ej */
			break;
	}

	gg_event_free(e);

przy okazji wiadomo, co oznaczaj± zdarzenia. czê¶æ z nich mo¿na ignorowaæ,
je¶li robi siê okrojonego klienta, np. wysy³aj±cego jedn± wiadomo¶æ z linii
komend.

po zalogowaniu nale¿y wys³aæ serwerowi listê u¿ytkowników, których mamy
w li¶cie kontaktów. ,,gg_notify()'' przyjmuje za argument tablicê zmiennych
typu ,,uin_t''. w odpowiedzi dostaniemy GG_EVENT_NOTIFY i tablicê struktur
,,struct gg_notify_reply'', je¶li kto¶ jest. po szczegó³y odsy³am do
libgadu.c, libgadu.h i ¼róde³ konsolowego klienta. je¶li dodajemy lub
usuwamy kogo¶ w trakcie dzia³ania, nale¿y skorzystaæ z ,,gg_add_notify()''
lub ,,gg_remove_notify()''. je¶li chcemy korzystaæ z listy osób blokowanych
lub takich, przed którymi siê ukrywamy, nale¿y korzystaæ z funkcji
,,gg_notify_ex()'', ,,gg_add_notify_ex()'' i ,,gg_remove_notify_ex()'',
które bior± dodatkowy argument mówi±cy, jak traktowaæ u¿ytkownika.
odpowiadaj± za to sta³e GG_USER_NORMAL, GG_USER_BLOCKED i GG_USER_OFFLINE.

¿eby zmieniæ stan na zajêty lub dostêpny, u¿ywamy ,,gg_change_status()'',
,,gg_change_status_descr()'' lub ,,gg_change_status_descr_time()''.

wysy³anie wiadomo¶ci za pomoc± ,,gg_send_message()''. parametr ,,class''
mówi, czy ma siê pojawiæ w osobnym okienku (GG_CLASS_MSG) czy w okienku
rozmowy (GG_CLASS_CHAT). funkcja zwraca numer sekwencyjny wiadomo¶ci,
którego mo¿emy u¿yæ do potwierdzenia. wiadomo¶æ, która ma byæ sformatowana
w odpowiedni sposób (pogrubienie, kursywa, kolory, itp.) wysy³amy za pomoc±
,,gg_send_message_richtext()''. wiadomo¶ci konferencyjne wysy³amy funkcjami
,,gg_send_message_confer()'' lub ,,gg_send_message_confer_richtext()''.

je¶li chcemy siê wylogowaæ, wywo³ujemy ,,gg_logoff()'' i potem zwalniamy
pamiêæ zwi±zan± z sesj± funkcj± ,,gg_free_session()''.

je¶li chcemy przypomnieæ swoje has³o, wywo³ujemy funkcjê
,,gg_remind_passwd2()'', a wynikow± strukturê ,,gg_http'' traktujemy
podobnie do ,,gg_session'':
 - sprawdzamy ->fd i ->check,
 - wywo³ujemy ,,gg_remind_passwd_watch_fd()'', gdy co¶ siê dzieje. funkcja
   ta zwraca -1 w przypadku b³êdu. je¶li zwraca 0, wywo³ujemy j±, póki
   ->state nie bêdzie równe GG_STATE_DONE lub GG_STATE_ERROR.
 - po zakoñczeniu, wywo³ujemy ,,gg_remind_passwd_free()''.

je¶li chcemy zarejestrowaæ konto lub zmieniæ has³o, nale¿y pobraæ token
z serwera. wywo³ujemy funkcjê ,,gg_token()'' i traktujemy podobnie
wynikowe ,,gg_http''. po skoñczonej operacji w ->data mamy strukturê
,,gg_token'' zawieraj±c± ,,tokenid'' i inne pola. w ->body mamy obrazek
z tokenem o rozmiarze ->body_size. pokazujemy go u¿ytkownikowi, ¿eby móg³
spisaæ token.

maj±c ju¿ token, je¶li chcemy zarejestrowaæ konto, wywo³ujemy
,,gg_register3()'' z odpowiednimi parametrami, a je¶li chodzi o zmianê has³a,
to ,,gg_change_passwd4()''.

konto usuwane jest funkcj± ,,gg_unregister3()''.

***

OBS£UGA KATALOGU PUBLICZNEGO GG 5.0 (na podstawie listu na ekg-devel)

skoro ju¿ dzia³a, opiszê aktualne API. g³ównym za³o¿eniem by³a
maksymalna niezale¿no¶æ od zmian w protokole, zmian nazw pól, dodawania
nowych itd. zastosowane podej¶cie mo¿e byæ trochê dziwne na pierwszy rzut
oka, ale podpatrzy³em to w powa¿niejszych projektach (np. libdbi).

je¶li chcemy szukaæ:

        gg_pubdir50_t req = gg_pubdir50_new(GG_PUBDIR50_SEARCH_REQUEST);

        if (!req)
                out_of_memory();

        /* szukamy po numerku... */

        gg_pubdir50_add(req, GG_PUBDIR50_UIN, "123456");

        /* lub... */

        gg_pubdir50_add(req, GG_PUBDIR50_FIRSTNAME, "Ania");
        gg_pubdir50_add(req, GG_PUBDIR50_GENDER, GG_PUBDIR50_GENDER_FEMALE);

        /* lub... */

        gg_pubdir50_add(req, GG_PUBDIR50_BIRTHYEAR, "1979 1985");
        gg_pubdir50_add(req, GG_PUBDIR50_START, "0");
        gg_pubdir50_add(req, GG_PUBDIR50_ACTIVE, GG_PUBDIR50_ACTIVE_TRUE);

        /* i w koñcu... */

        gg_pubdir50(sesja, req);

        /* i zwalniamy pamiêæ, albo sobie gdzie¶ zachowujemy. whatever */

        gg_pubdir50_free(req);

jak witaæ, gg_pubdir50_new() tworzy obiekt opisuj±cy operacjê katalogu,
gg_pubdir50_add() dodaje kolejne parametry. rodzaj parametru jest w
rzeczywi¶ci sta³± tekstow±, np. GG_PUBDIR50_UIN to "FmNumber". nale¿y
pamiêtaæ, ¿e wszystkie argumenty s± tekstami. nie trzeba siê bawiæ w ich
alokowanie czy co¶ takiego. biblioteka sobie sama zapamiêta. teksty musz±
byæ oczywi¶cie w CP1250. na koñcu wywo³ujemy gg_pubdir50() i tyle. funkcja
ta zwraca numer sekwencyjny wyszukiwania, który mo¿emy sobie zachowaæ dla
pó¼niejszych referencji.

¿eby otrzymaæ wynik, nale¿y obs³u¿yæ zdarzenia GG_EVENT_PUBDIR50_SEARCH_REPLY,
GG_EVENT_PUBDIR50_WRITE i GG_EVENT_PUBDIR50_READ. dla przyk³adu, obs³uga
wyników wyszukiwania wygl±da nastêpuj±co:

        gg_search50_t res = zdarzenie->event.search50;
        int count = gg_search50_count(res);

        if (count < 1) {
                wiadomo¶æ("Nie znaleziono");
                return;
        }

        for (int i = 0; i < count; i++) {
                const char *uin, *first, *nick, *born, *city, *status;

                uin = gg_pubdir50_get(res, i, GG_PUBDIR50_UIN);
                first = gg_pubdir50_get(res, i, GG_PUBDIR50_FIRSTNAME);
                nick = gg_pubdir50_get(res, i, GG_PUBDIR50_NICK);
                born = gg_pubdir50_get(res, i, GG_PUBDIR50_BIRTHYEAR);
                city = gg_pubdir50_get(res, i, GG_PUBDIR50_CITY);
                status = gg_pubdir50_get(res, i, GG_PUBDIR50_STATUS);

                printf("Numer: %s\nImiê: %s\nPseudonim: %s\n"
                        "Urodzony: %s\nMiejscowo¶æ: %s\n", uin,
                        first, nick, born, city);

                switch ((status) ? atoi(status) : -1) {
                        case GG_STATUS_AVAIL:
                                printf("Dostêpny\n");
                                break;
                        case GG_STATUS_BUSY:
                                printf("Zajêty\n");
                                break;
                        default:
                                printf("Niedostêpny\n");
                }

                printf("\n");
        }

        gg_event_free(zdarzenie);

je¶li chcemy wiedzieæ, od jakiego numeru zacz±æ wyszukiwanie, ¿eby dostaæ
dalsz± czê¶æ, u¿ywamy gg_pubdir50_next(). je¶li chcemy numer sekwencyjny,
u¿ywamy gg_pubdir50_seq().

w ¿adnym wypadku nie mo¿na siê odwo³ywaæ do pól gg_pubdir50_t, poniewa¿
mog± siê zmieniaæ miêdzy wersjami biblioteki. dziêki odwo³ywaniu siê przez
funkcje, mamy pewno¶æ, ¿e bez wzglêdu na zmiany API/ABI mamy to samo.
dodatkowo, je¶li dojd± jakie¶ opcje wyszukiwania, nie trzeba w bibliotece
niczego zmieniaæ -- ¿adnych struktur, itd. po prostu odwo³ujemy siê do
kolejnego pola przez gg_pubdir50_add() i gg_pubdir50_get().

***

OBS£UGA LISTY KONTAKTÓW GG 6.0

od wersji 6.0 import i eksport listy kontaktów jest zawarty w sesji klienta,
nie wymaga osobnego po³±czenia http. aby wys³aæ listê kontaktów, wywo³ujemy:

	gg_userlist_request(sesja, GG_USERLIST_PUT, lista_kontaktów);

w odpowiedzi dostaniemy od serwera zdarzenie GG_EVENT_USERLIST z polem
,,type'' równym GG_USERLIST_PUT_REPLY.

je¶li chcemy pobraæ listê kontaktów z serwera, wywo³ujemy:

	gg_userlist_request(sesja, GG_USERLIST_GET, NULL);

i oczekujemy zdarzenia GG_EVENT_USERLIST z ,,type'' GG_USERLIST_GET_REPLY.
zawarto¶æ listy kontaktów znajdziemy w polu ,,reply''.

***

WIADOMO¦CI GRAFICZNE

informacje o obrazku s± zawarte w bloku wiadomo¶ci dotycz±cym formatowania
tekstu. dla danego znaku tekstu pole ,,font'' zawiera GG_FONT_IMAGE i zaraz
potem znajduje siê struktura gg_msg_richtext_image, np.

  0x00	koniec wiadomo¶ci
  0x02	.flag = 0x02				gg_msg_richtext
  0x0d	.length = 0x000d			|
  0x00  |					|
  0x00  .position = 0x00			gg_msg_richtext_format
  0x00  |					|
  0x80  font = GG_FONT_IMAGE 			|
  0x90	.unknown1 = 0x0109			gg_msg_richtext_image
  0x01	|					|
  0x12	.size = 0x3412				|
  0x34	|					|
  0x00	|					|
  0x00	|					|
  0x56	.crc32 = 0x7856				|
  0x78	|					|
  0x00	|					|
  0x00	|					|

wiemy zatem, ¿e obrazek ma d³ugo¶æ 0x3412 i sumê kontroln± 0x7856. je¶li
nie mamy takiego obrazka zapisanego u siebie, wywo³ujemy funkcjê:

	gg_image_request(sesja, nadawca, rozmiar, suma_kontrolna);

i czekam na zdarzenie GG_EVENT_IMAGE_REPLY, w którym wa¿ne s± dla nas
pola .size, .crc32, .filename (nazwa obrazka), .image (tre¶æ obrazka).
rodzaj pliku graficznego nie jest okre¶lony przy transmisji. libgadu
ignoruje wszystkie obrazki, które nie by³y zamówione, ¿eby unikn±æ
zajêcia ca³ej dostêpnej pamiêci, gdy kto¶ nieustannie wysy³a nam ró¿ne
obrazki.

je¶li wysy³amy wiadomo¶æ graficzn± musimy obs³ugiwaæ zdarzenie
GG_EVENT_IMAGE_REQUEST. w polach .size i .crc32 s± informacje o
obrazku, którego potrzebuje nasz rozmówca. wysy³amy funkcj±
gg_image_reply(sesja, odbiorca, nazwa_pliku, zawarto¶æ_pliku, d³ugo¶æ);

***

BEZPO¦REDNIE PO£¡CZENIA

gadu-gadu, w przeciwieñstwie do irc, umo¿liwia po³±czenia w obie strony,
bez wzglêdu na to, który klient nadaje, a który odbiera. do tego, je¶li
obie strony wychodz± z tego samego adresu IP, serwer informuje ich o ich
adresach wewnêtrznych z tego samego LANu. mamy kilka mo¿liwych sytuacji:

a) mam publiczny lub niepubliczny adres IP i chcê wys³aæ plik do kogo¶
   z publicznym adresem -- ³±czê siê z jego klientem, przedstawiam siê,
   mówiê czego chcê i je¶li to zaakceptuje, zaczynam wysy³aæ plik. bardzo
   to przypomina zwyk³e po³±czenia dcc klientów irc.

b) mam publiczny adres IP i wysy³am plik do kogo¶ za maskarad± -- wysy³am
   do niego odpowiedni pakiet ctcp (client-to-client protocol). jest to
   pakiet klasy GG_CLASS_CTCP (0x10) o tre¶ci sk³adaj±cej siê z jednego
   znaku o kodzie 0x02. druga strona, odebrawszy taki pakiet ³±czy siê
   z nami, mówi, ¿e proszono j± o po³±czenie i czeka na dalsze instrukcje.
   wtedy wysy³amy informacjê, ¿e owszem, chcemy wys³aæ plik, mówimy jaki
   i je¶li druga strona to zaakceptuje, nadajemy.

c) mam niepubliczny adres IP, tak samo jak i druga strona -- tutaj
   nawi±zanie po³±czenia jest mo¿liwe tylko i wy³±cznie, gdy oba klienty
   znajduj± siê w tej samej sieci (tj. oba ³±cz± siê z serwerem GG z tego
   samego adresu zewnêtrznego) i wygl±da to wtedy identycznie jak w punkcie
   a).

to, czy mo¿emy siê z kim¶ po³±czyæ widaæ po porcie, jaki dostajemy w
pakietach gg_notify_reply. je¶li jest mniejszy ni¿ 10, po³±czenie nie
jest mo¿liwe, a wtedy wysy³amy pakiet ctcp za pomoc± funkcji
gg_dcc_request().

ka¿de po³±czenie zwi±zanie z dcc opisywane jest przez strukturê gg_dcc.
najwa¿niejsze jest GG_SESSION_DCC_SOCKET, które odpowiada za przychodz±ce
po³±czenia. tworzymy je przez:

	struct gg_dcc *socket = gg_dcc_socket_create(uin, port);

	if (!socket)
		b³±d("nie mogê otworzyæ socketu");

	dodaj_do_listy_przegl±danych_deskryptorów(socket);

port mo¿e wynosiæ 0, a wtedy libgadu samo we¼mie pierwszy lepszy
z brzegu. w razie powodzenia zwraca zaalokowan± strukturê gg_dcc,
której najbardziej interesuj±cym polem jest gg_dcc->port zawieraj±ce
numer przyznanego portu. je¶li funkcja zwróci NULL, patrzymy na errno.
EINVAL to niew³a¶ciwie parametry, ENOMEM brak pamiêci, a reszta
mo¿liwych b³êdów to te zwi±zane z socketami, typu EADDRINUSE gdy nie
mo¿e wolnego portu znale¼æ.

teraz wypada³oby ustawiæ zmienn± ,,gg_dcc_port'' i po³±czyæ siê z
serwerem GG, ¿eby og³osiæ swoje namiary. og³aszany adres IP bêdzie
brany z po³±czenia z serwerem.

	gg_dcc_port = socket->port;
	po³±cz_siê_z_serwerem();

w ka¿dym razie, gdy pojawi siê co¶ na deskryptorze, wywo³ujemy:

	struct gg_event *event = gg_dcc_watch_fd(socket);

	if (!event) {
		usuñ_z_listy_przegl±danych_deskryptorów(socket);
		gg_dcc_free(socket);
		b³±d("powa¿ny b³±d"):
	}

b³±d jest zwracany tylko w naprawdê krytycznych sytuacjach, gdy
brakuje pamiêci, lub nie powiod³a siê operacja na socketach, która
nie mia³a siê nie powie¶æ (i przy okazji dalsza zabawa jest
kompletnie bezcelowa).

je¶li b³êdu nie bêdzie, dostajemy informacje o zdarzeniu. w przypadku
GG_SESSION_DCC_SOCKET mog± to byæ:

1) GG_EVENT_NONE -- nic ciekawego siê nie wydarzy³o.

2) GG_EVENT_DCC_ERROR -- wyst±pi³ b³±d, którego kod znajduje siê w
   event->event.dcc_error. w przypadku tego typu sesji mo¿liwy jest
   tylko GG_ERROR_DCC_HANDSHAKE, który mówi, ¿e nie uda³o siê nawi±zaæ
   po³±czenia z klientem.

3) GG_EVENT_DCC_NEW -- nowe po³±czenie od klienta. w polu
   event->event.dcc_new jest struktura gg_dcc typu GG_SESSION_DCC,
   któr± dodajemy do listy przegl±danych deskryptorów.

w ka¿dym z tych wypadków nale¿y po sprawdzeniu zdarzenia wywo³aæ funkcjê:

	gg_event_free(socket->event);

by zwolniæ pamiêæ po zdarzeniu.


gdy nadejdzie po³±czenie i dopiszemy je do listy przegl±danych deskryptorów,
musimy zwracaæ uwagê na nastêpuj±ce zdarzenia:

1) GG_EVENT_NONE -- nic siê nie zdarzy³o.

2) GG_EVENT_DCC_CLIENT_ACCEPT -- klient siê przedstawi³ i czeka na
   autoryzacjê po³±czenia. sprawdzamy gg_dcc->uin czy jest naszym numerem
   i czy gg_dcc->peer_uin jest na naszej li¶cie kontaktów i czy chcemy z
   nim nawi±zywaæ po³±czenie. je¶li nie, to po prostu usuwamy po³±czenie:

   	if (!akceptujemy_po³±czenie(klient->uin, klient->peer_uin)) {
		usuñ_z_listy_przegl±danych_deskryptorów(client);
		gg_dcc_free(klient);
	}

3) GG_EVENT_DCC_CALLBACK -- poprosili¶my klienta, ¿eby siê z nami po³±czy³
   za pomoc± gg_dcc_request() i on teraz pyta siê, czego chcemy. zaraz po
   tym zdarzeniu nale¿y wywo³aæ funkcjê:

	gg_dcc_set_type(klient, rodzaj_po³±czenia);

   gdzie rodzaj to GG_SESSION_DCC_SEND albo GG_SESSION_DCC_VOICE. je¶li
   wysy³amy plik, mo¿na od razu wywo³aæ gg_dcc_fill_file_info(), ale nie
   jest to wymagane. kiedy przyjdzie pora, libgadu sama nas o to poprosi.

4) GG_EVENT_DCC_NEED_FILE_ACK -- klient chce wys³aæ nam plik. w strukturze
   gg_dcc->file_info znajduj± siê wszystkie informacje na temat pliku, jak
   jego nazwa, rozmiar, atrybuty, data i czas utworzenia itp. je¶li nie
   chcemy pliku, zamykamy po³±czenie w podobny sposób jak przy braku
   autoryzacji. libgadu jeszcze nie potrafi odpowiadaæ negatywnie na pro¶by
   po³±czeñ dcc. je¶li chcemy plik, otwieramy plik do zapisu i numer jego
   deskryptora zapisujemy do gg_dcc->file_fd. je¶li chcemy wznowiæ przerwany
   transfer, otwieramy plik w trybie dopisywania i do gg_dcc->offset
   wpisujemy ile bajtów ju¿ mamy i od którego offsetu odbieramy. dalej
   libgadu zajmie siê transferem.

5) GG_EVENT_DCC_NEED_FILE_INFO -- wcze¶niej poprosili¶my drug± stronê by
   siê z nami po³±czy³a, bo jest za maskarad±, a my chcemy wys³aæ plik.
   w tym wypadku mo¿emy albo sami wype³niæ strukturê gg_dcc->file_info,
   któr± biblioteka wy¶le drugiej stronie, albo skorzystaæ z funkcji
   gg_dcc_fill_file_info().

   	if (gg_dcc_fill_file_info(klient, nazwa_pliku)) {
		b³±d("nie mogê otworzyæ pliku");
		usuñ_z_listy_przegl±danych_deskryptorów(klient);
		gg_dcc_free(klient);
	}

6) GG_EVENT_DCC_DONE -- zakoñczono transfer, mo¿na ju¿ nie patrzeæ na
   deskryptor i zwolniæ pamiêæ po po³±czeniu.

7) GG_EVENT_DCC_ERROR -- b³±d. mo¿liwy kod b³êdu to GG_ERROR_DCC_HANDSHAKE
   gdy nie powiod³o siê ustanowienie po³±czenia z klientem, GG_ERROR_DCC_NET
   kiedy nie uda³o siê wys³aæ lub odczytaæ czego¶ z socketa, GG_ERROR_DCC_FILE
   gdy nie mo¿na by³o odczytaæ albo zapisaæ do pliku, GG_ERROR_DCC_EOF gdy
   plik lub po³±czenie zbyt wcze¶nie siê skoñczy, GG_ERROR_DCC_REFUSED gdy
   u¿ytkownik po drugiej stronie odmówi³ po³±czenia.

tutaj równie¿ nale¿y pamiêtaæ o wywo³ywaniu gg_event_free().


je¶li chcemy sami wys³aæ plik, sprawdzamy najpierw, czy druga strona
mo¿e przyj±æ po³±czenie, patrz±c na jej port. je¶li powy¿ej 10, mo¿emy
¶mia³o wywo³aæ funkcjê:

	struct gg_dcc *klient = gg_dcc_send_file(adres_ip, port, nasz_uin, jego_uin);

	if (!klient)
		b³±d("nie mo¿na ustanowiæ po³±czenia");

zaraz potem mo¿emy wywo³aæ funkcjê gg_dcc_fill_file_info() by uzupe³niæ
informacjê o pliku...

	gg_dcc_fill_file_info(klient, nazwa_pliku);

...ale je¶li tego nie zrobimy teraz, biblioteka poprosi nas o to
w odpowiedniej za pomoc± zdarzenia GG_EVENT_DCC_NEED_FILE_INFO.

je¶li port jest podejrzanie niski, znaczy ¿e po³±czenie jest niemo¿liwe
i wtedy wywo³ujemy funkcjê:

	gg_dcc_request(sesja_gg, jego_uin);

gdzie sesja_gg to nasza sesja GG (jako¶ musimy wys³aæ wiadomo¶æ),
a jego_uin to numer drugiej strony. spowoduje ona, ¿e druga strona
spróbuje siê z nami po³±czyæ, je¶li ma tak± mo¿liwo¶æ.


gdy otrzymamy wiadomo¶æ klasy GG_CLASS_CTCP o tre¶ci 0x02 znaczy,
¿e kto¶ chce nam co¶ przes³aæ i mamy siê z nim po³±czyæ. wywo³ujemy
wtedy:

	struct gg_dcc *klient = gg_dcc_get_file(adres_ip, port, nasz_uin, jego_uin);

	if (!klient)
		b³±d("nie mo¿na ustanowiæ po³±czenia");

dalej tak samo, jak przy zwyk³ym odbieraniu pliku.

$Id$
